#pragma once

namespace Vector {
namespace BLF {

/* unsigned 8 bit */
typedef unsigned char byte;

/* unsigned 16 bit */
typedef unsigned short word;

/* unsigned 32 bit */
typedef unsigned long dword;
typedef unsigned long ulong;

/* unsigned 64 bit */
typedef unsigned long long ulonglong;

/* pointer to string */
typedef char * lpstr;

/* pointer to data */
typedef byte * lpbyte;

/* color reference */
typedef unsigned long colorref;

/* CAN Message Flags */
typedef enum CAN_MSG {
    CAN_MSG_TX = (1<<0),
    CAN_MSG_NERR = (1<<5),
    CAN_MSG_WU = (1<<6),
    CAN_MSG_RTR = (1<<7)
} CAN_MSG;

constexpr unsigned long BL_OBJ_SIGNATURE = -1;

/**
 * Object header base structure.
 */
typedef struct VBLObjectHeaderBase {
    /**
     * Object signature, must be BL_OBJ_SIGNATURE.
     */
    dword mSignature;

    /**
     * Size of header in bytes, set this member to
     * sizeof(VBLObjectHeader) or
     * sizeof(VBLObjectHeader2) depending on
     * the object header type used for the object. */
    word mHeaderSize;

    /**
     * Version number of object header.
     *
     * Set this member to 1 if the object has a member
     * of type VBLObjectHeader.
     *
     * Set this member to 2 if the object has a member
     * of type VBLObjectHeader2.
     */
    word mHeaderVersion;

    /**
     * Object size in bytes.
     */
    dword mObjectSize;

    /**
     * Object type (BL_OBJ_TYPE_*).
     */
    dword mObjectType;
} VBLObjectHeaderBase;

/**
 * Object header. Version 1.
 */
typedef struct VBLObjectHeader {
    /**
     * Common object header base.
     */
    VBLObjectHeaderBase mBase;

    /**
     * Unit of object timestamp. Following values are
     * possible:
     *
     * - 1: Object time stamp is saved as multiple of ten
     *   microseconds
     *   (BL_OBJ_FLAG_TIME_TEN_MICS)
     * - 2: Object time stamp is saved in nanoseconds.
     *   (BL_OBJ_FLAG_TIME_ONE_NANS)
     */
    enum mObjectFlags : dword {
        BL_OBJ_FLAG_TIME_TEN_MICS = 1,
        BL_OBJ_FLAG_TIME_ONE_NANS = 2
    } mObjectFlags;

    /**
     * Reserved, must be 0.
     */
    word mReserved;

    /**
     * Object specific version, has to be set to 0 unless
     * stated otherwise in the description of a specific
     * event.
     */
    word mObjectVersion;

    /**
     * Time stamp of this object in the unit specified in
     * mObjectFlags.
     */
    ulonglong mObjectTimeStamp;
} VBLObjectHeader;

/**
 * Object header. Version 2.
 */
typedef struct VBLObjectHeader2 {
    /**
     * Common object header base.
     */
    VBLObjectHeaderBase mBase;

    /**
     * Unit of object timestamp. Following values are possible:
     *
     * - 1: Object time stamp is saved as multiple of ten
     *   microseconds
     *   (BL_OBJ_FLAG_TIME_TEN_MICS)
     * - 2: Object time stamp is saved in nanoseconds.
     *   (BL_OBJ_FLAG_TIME_ONE_NANS)
     */
    enum mObjectFlags : dword {
        BL_OBJ_FLAG_TIME_TEN_MICS = 1,
        BL_OBJ_FLAG_TIME_ONE_NANS = 2
    } mObjectFlags;

    /**
     * Bit field. The bits have the following meanings:
     *
     * - Bit 0:
     *   Determines whether original timestamp member
     *   is valid (1) or not (0).
     * - Bit 1:
     *   Timestamp is generated by software (1) or by
     *   hardware (0).
     * - Bit 5:
     *   This bit has protocol specific meaning.
     */
    byte mTimeStampStatus;

    /**
     * Reserved, must be 0.
     */
    byte mReserved1;

    /**
     * Object specific version, has to be set to 0 unless
     * stated otherwise in the description of a specific
     * event.
     */
    word mObjectVersion;

    /**
     * Time stamp of this object in the unit specified in
     * mObjectFlags.
     */
    ulonglong mObjectTimeStamp;

    /**
     * Original timestamp in the unit specified in
     * mObjectFlags.
     */
    ulonglong mOriginalTimeStamp;
} VBLObjectHeader2;

constexpr dword BL_OBJ_TYPE_CAN_MESSAGE = -1;

/**
 * CAN data or CAN remote frame received or transmitted on a CAN channel.
 */
typedef struct VBLCANMessage {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Channel the frame was sent or received.
     */
    word mChannel;

    /**
     * CAN Message Flags
     */
    byte mFlags;

    /**
     * Data length code of frame (number of valid data
     * bytes, max. 8)
     */
    byte mDLC;

    /**
     * Frame identifier.
     */
    dword mID;

    /**
     * CAN data bytes
     */
    byte mData[8];
} VBLCANMessage;

constexpr dword BL_OBJ_TYPE_CAN_MESSAGE2 = -1;

/**
 * CAN data or CAN remote frame received or transmitted on a CAN channel.
 */
typedef struct VBLCANMessage2 {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Channel the frame was sent or received.
     */
    word mChannel;

    /**
     * CAN Message Flags
     */
    byte mFlags;

    /**
     * Data length code of frame (number of valid data
     * bytes, max. 8)
     */
    byte mDLC;

    /**
     * Frame identifier.
     */
    dword mID;

    /**
     * CAN data bytes
     */
    byte mData[8];

    /**
     * Message duration [in ns]. Not including 3
     * Interframe Space bit times and by Rx-messages
     * also not including 1 End-Of-Frame bit time
     */
    dword mFrameLength;

    /**
     * Total number of bits of the message including
     * EOF and Interframe space [in bits]
     */
    byte mBitCount;

    /**
     * Reserved, must be 0
     */
    byte mReserved1;

    /**
     * Reserved, must be 0
     */
    word mReserved2;
} VBLCANMessage2;

constexpr dword BL_OBJ_TYPE_CAN_FD_MESSAGE_64 = -1;

/**
 * CAN FD data frame, or CAN data- or remote frame on a CAN FD channel.
 */
typedef struct VBLCANFDMessage64 {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Channel the frame was sent or received.
     */
    byte mChannel;

    /**
     * Data length code of frame.
     *
     * - DLC=0-8: CAN=0-8, CAN FD=0-8
     * - DLC=9: CAN=8, CAN FD=12
     * - DLC=10: CAN=8, CAN FD=16
     * - DLC=11: CAN=8, CAN FD=20
     * - DLC=12: CAN=8, CAN FD=24
     * - DLC=13: CAN=8, CAN FD=32
     * - DLC=14: CAN=8, CAN FD=48
     * - DLC=15: CAN=8, CAN FD=64
     */
    byte mDLC;

    /**
     * Valid payload length of mData, can differ from
     * DLC value.
     */
    byte mValidDataBytes;

    /**
     * (Bits 0-3) Number of required tranmission
     * attempts, (Bits 4-7) Max Number of
     * transmission attempts.
     */
    byte mTxCount;

    /**
     * Frame identifier.
     */
    dword mID;

    /**
     * Message duration [in ns]. Not including 3
     * interframe-space bit times and by Rx-messages
     * also not including 1 end-of-frame bit time
     */
    dword mFrameLength;

    /**
     * - Bit#=0 (0x0001): Must be 0
     * - Bit#=1 (0x0002): Reserved, for internal use
     * - Bit#=2 (0x0004): 1=NERR (1=single wire on low speed CAN)
     * - Bit#=3 (0x0008): 1=High voltage wake up
     * - Bit#=4 (0x0010): 1=Remote frame (only CAN)
     * - Bit#=5 (0x0020): Reserved, must be 0
     * - Bit#=6 (0x0040): 1=Tx Acknowledge
     * - Bit#=7 (0x0080): 1=Tx Request
     * - Bit#=8 (0x0100): Reserved, must be 0
     * - Bit#=9 (0x0200): SRR (CAN FD)
     * - Bit#=10 (0x0400): R0
     * - Bit#=11 (0x0800): R1
     * - Bit#=12 (0x1000): EDL, 0: CAN frame, 1: CAN FD frame
     * - Bit#=13 (0x2000): BRS (CAN FD)
     * - Bit#=14 (0x4000): ESI
     * - Bit#=15 (0x8000): Reserved, must be 0
     * - Bit#=16 (0x10000): Reserved, must be 0
     * - Bit#=17 (0x20000): 1=Frame is part of a burst
     * - Bit#=18-31: Reserved, must be 0
     */
    dword mFlags;

    /**
     * CAN- or CAN-FD bit timing configuration for
     * arbitration phase, may be 0, if not supported by
     * hardware/driver
     *
     * - Bit 0-7: Quartz Frequency
     * - Bit 8-15: Prescaler
     * - Bit 16-23: BTL Cycles
     * - Bit 24-31: Sampling Point
     */
    dword mBtrCfgArb;

    /**
     * CAN-FD bit timing configuration for data
     * phase, may be 0, if not supported by
     * hardware/driver. See mBtrCfgArb.
     */
    dword mBtrCfgData;

    /**
     * Time offset of bit rate switch within BRS field
     * in nanoseconds
     */
    dword mTimeOffsetBrsNs;

    /**
     * Time offset of bit rate switch within CRC
     * delimiter field in nanoseconds
     */
    dword mTimeOffsetCRCDelNs;

    /**
     * Bit count of the message
     */
    word mBitCount;

    /**
     * Direction of the message
     */
    byte mDir;

    /**
     * Reserved, must be 0
     */
    byte mReserved1;

    /**
     * Reserved, must be 0
     */
    dword mReserved2;

    /**
     * Data bytes (the actual length may be shorter
     * than 64 bytes, according to the value of
     * mDLC).
     */
    byte mData[64];
} VBLCANFDMessage64;

constexpr dword BL_OBJ_TYPE_CAN_ERROR = -1;

/**
 * CAN error frame received or transmitted on a CAN channel.
 */
typedef struct VBLCANErrorFrame {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Channel the frame was sent or received.
     */
    word mChannel;

    /**
     * Length of error frame - can be left 0.
     */
    word mLength;
} VBLCANErrorFrame;

constexpr dword BL_OBJ_TYPE_CAN_ERROR_EXT = -1;

/**
 * Extended CAN error frame received or transmitted on a CAN channel.
 */
typedef struct VBLCANErrorFrameExt {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Channel the frame was sent or received.
     */
    word mChannel;

    /**
     * Length of error frame, unused, may be 0.
     */
    word mLength;

    /**
     * Defines what additional information is valid.
     * Following values are possible:
     *
     * - 1: SJA 1000 ECC is valid (member mECC)
     * - 2: Vector CAN Core Error Code is valid.
     * - 4: Vector CAN Core Error Position
     * - 8: Vector CAN Core Frame Length in ns
     */
    dword mFlags;

    /**
     * Content of Philips SJA1000 Error Code Capture
     * (ECC) register, or the Vector CAN-Core error
     * register (see also mFlags).
     *
     * SJA1000-ECC
     *
     * See documentation of Philips SJA1000 CAN
     * Controller.
     *
     * Vector CAN-Core
     *
     * - Bit 0-5 Meaning:
     *   - 0: Bit Error
     *   - 1: Form Error
     *   - 2: Stuff Error
     *   - 3: Other Error
     *   - 4: CRC Error
     *   - 5: Ack-Del-Error
     * - Bit 6-7 Meaning:
     *   - 0: RX-NAK-Error
     *   - 1: TK-NAK-Error
     *   - 2: RX-Error
     *   - 3: TX-Error
     */
    byte mECC;

    /**
     * Bit position of the error frame in the corrupted
     * message.
     */
    byte mPosition;

    /**
     * Data length code of the corrupted message.
     */
    byte mDLC;

    /**
     * Reserved, must be 0.
     */
    byte mReserved1;

    /**
     * Length of the error frame in nanoseconds (time
     * difference between Start Of Frame and End Of
     * Frame)
     */
    dword mFrameLengthInNS;

    /**
     * Message ID of the corrupted message.
     */
    dword mID;

    /**
     * Extended error flags.
     *
     * - Bit 0-4: Segment (only SJA1000)
     * - Bit 5: Direction, 1=RX
     * - Bit 6-11: Error Code
     *   - 0: Bit Error
     *   - 1: Form Error
     *   - 2: Stuff Error
     *   - 3: Other Error
     *   - 4: CRC Error
     *   - 5: ACK-DEL Error
     * - Bit 12-13: Extended Direction
     *   - 0: RX NAK
     *   - 1: TX NAK
     *   - 2: RX
     *   - 3: TX
     * - Bit 14: 1=The error frame was send from the application
     */
    word mFlagsExt;

    /**
     * Reserved, must be 0.
     */
    word mReserved2;

    /**
     * Message data.
     */
    byte mData[8];
} VBLCANErrorFrameExt;

constexpr dword BL_OBJ_TYPE_CAN_FD_ERROR_64 = -1;

/**
 * CAN-FD error frame received or transmitted on a CAN-FD channel.
 */
typedef struct VBLCANFDErrorFrame64 {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Channel the frame was sent or received.
     */
    byte mChannel;

    /**
     * Data length code of the corrupted message.
     */
    byte mDLC;

    /**
     * Number of data bytes of the corrupted message.
     */
    byte mValidDataBytes;

    /**
     * Content of Philips SJA1000 Error Code Capture
     * register, or the Vector CAN-Core error register.
     * See field mECC of VBLCANErrorFrameExt.
     */
    byte mECC;

    /**
     * Defines what additional information is valid. See
     * field mFlags of VBLCANErrorFrameExt.
     */
    word mFlags;

    /**
     * Extended error flags. See field mFlagsExt of
     * VBLCANErrorFrameExt.
     */
    word mErrorCodeExt;

    /**
     * CAN-FD specific flags.
     *
     * - Bit 0-3 Meaning:
     *   - unused
     * - Bit 0-4 Meaning:
     *   - 0: Error in Arbitration Phase
     *   - 1: Error in Data Phase
     * - Bit 5 Meaning:
     *   - 0: ESI is 0
     *   - 1: ESI is 1
     * - Bit 6 Meaning
     *   - 0: BRS is 0
     *   - 1: BRS is 1
     * - Bit 7 Meaning
     *   - 0: EDL is 0
     *   - 1: EDL is 1
     */
    word mExtFlags;

    /**
     * Reserved, must be 0.
     */
    word mReserved1;

    /**
     * Message ID of the corrupted message.
     */
    dword mID;

    /**
     * Length of the error frame in nanoseconds (time
     * difference between Start Of Frame and End Of
     * Frame)
     */
    dword mFrameLength;

    /**
     * CAN-FD bit timing configuration for arbiration
     * phase, may be 0, if not supported by
     * hardware/driver
     *
     * - Bit 0-7: Quartz Frequency
     * - Bit 8-15: Prescaler
     * - Bit 16-23: BTL Cycles
     * - Bit 24-31: Sampling Point
     */
    dword mBtrCfgArb;

    /**
     * CAN-FD bit timing configuration for arbiration
     * phase, may be 0, if not supported by
     * hardware/driver. See mBtrCfgArb.
     */
    dword mBtrCfgData;

    /**
     * Time offset of bit rate switch within BRS field in
     * nanoseconds
     */
    dword mTimeOffsetBrsNs;

    /**
     * Time offset of bit rate switch within CRC
     * delimiter field in nanoseconds
     */
    dword mTimeOffsetCRCDelNs;

    /**
     * CRC checksum of corrupted message.
     */
    dword mCRC;

    /**
     * Bit position of the error frame in the corrupted
     * message.
     */
    word mErrorPosition;

    /**
     * Reserved, must be 0.
     */
    word mReserved2;

    /**
     * CAN FD data bytes (the actual length may be
     * shorter than 64 bytes, according to the value of
     * mDLC, e.g. when DLC is 12 mData has length
     * 24)
     */
    byte mData[64];
} VBLCANFDErrorFrame64;

constexpr dword BL_OBJ_TYPE_CAN_OVERLOAD = -1;

/**
 * CAN overload frame received or transmitted on a CAN channel.
 */
typedef struct VBLCANOverloadFrame {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Channel the frame was sent or received.
     */
    word mChannel;

    /**
     * Reserved, must be 0
     */
    word mDummy;
} VBLCANOverloadFrame;

constexpr dword BL_OBJ_TYPE_CAN_STATISTIC = -1;

/**
 * CAN driver statistic data for a CAN channel.
 */
typedef struct VBLCANDriverStatistic {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * CAN channel the statistic data belongs to.
     */
    word mChannel;

    /**
     * Busload in 1/100 percent (e.g. 100 means
     * 1%)
     */
    word mBusLoad;

    /**
     * Number of standard data frames sent on
     * that channel.
     */
    dword mStandardDataFrames;

    /**
     * Number of extended data frames sent on
     * that channel.
     */
    dword mExtendedDataFrames;

    /**
     * Number of remote data frames sent on that
     * channel.
     */
    dword mStandardRemoteFrames;

    /**
     * Number of extended remote data frames
     * sent on that channel.
     */
    dword mExtendedRemoteFrames;

    /**
     * Number of error frams sent on that channel
     */
    dword mErrorFrames;

    /**
     * Number of overload frams sent on that
     * channel.
     */
    dword mOverloadFrames;
} VBLCANDriverStatistic;

constexpr dword BL_OBJ_TYPE_CAN_DRIVER_ERROR = -1;

/**
 * CAN driver error information for transceiver of a CAN channel.
 */
typedef struct VBLCANDriverError {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * CAN channel the driver error information
     * belongs to.
     */
    word mChannel;

    /**
     * Number of transmit errors that occurred in CAN
     * controller for that channel.
     */
    byte mTXErrors;

    /**
     * Number of receive errors that occurred in CAN
     * controller for that channel.
     */
    byte mRXErrors;

    /**
     * Error code
     */
    dword mErrorCode;
} VBLCANDriverError;

constexpr dword BL_OBJ_TYPE_CAN_DRIVER_ERROR_EXT = -1;
/**
 * Extended CAN driver error information for transceiver of a CAN channel.
 */
typedef struct VBLCANDriverErrorExt {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * CAN channel the driver error information
     * belongs to.
     */
    word mChannel;

    /**
     * Number of transmit errors that occurred in CAN
     * controller for that channel.
     */
    byte mTXErrors;

    /**
     * Number of receive errors that occurred in CAN
     * controller for that channel.
     */
    byte mRXErrors;

    /**
     * Error code
     */
    dword mErrorCode;

    /**
     * To be defined.
     */
    dword mFlags;

    /**
     * To be defined.
     */
    byte mState;

    /**
     * Reserved, must be 0
     */
    byte mReserved1;

    /**
     * Reserved, must be 0
     */
    word mReserved2;

    /**
     * Reserved, must be 0
     */
    dword mReserved3[4];
} VBLCANDriverErrorExt;

constexpr dword BL_OBJ_TYPE_CAN_DRIVER_SYNC = -1;

/**
 * Event that occurs when hardware sync is executed.
 */
typedef struct VBLCANDriverHwSync {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Application channel
     */
    word mChannel;

    /**
     * The following values are possible:
     *
     * - 1: sync was sent from this channel
     *   (BL_HWSYNC_FLAGS_TX)
     * - 2: external sync received
     *   (BL_HWSYNC_FLAGS_RX)
     * - 4: sync received but generated from this
     *   hardware (BL_HWSYNC_FLAGS_RX_THIS)
     */
    enum mFlags : byte {
        BL_HWSYNC_FLAGS_TX = 1,
        BL_HWSYNC_FLAGS_RX = 2,
        BL_HWSYNC_FLAGS_RX_THIS = 4
    } mFlags;

    /**
     * Reserved, must be 0
     */
    byte mDummy;
} VBLCANDriverHwSync;

constexpr dword BL_OBJ_TYPE_ENV_INTEGER = -1;
constexpr dword BL_OBJ_TYPE_ENV_DOUBLE  = -1;
constexpr dword BL_OBJ_TYPE_ENV_STRING  = -1;
constexpr dword BL_OBJ_TYPE_ENV_DATA    = -1;

/**
 * Environment variable that can be used with CANoe.
 */
typedef struct VBLEnvironmentVariable {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Length of the name of the environment variable
     * (without terminating 0)
     */
    dword mNameLength;

    /**
     * Length of the data of the environment variable in
     * bytes.
     */
    dword mDataLength;

    /**
     * Name of the environment variable.
     */
    lpstr mName;

    /**
     * Data value of the environment variable.
     */
    lpbyte mData;
} VBLEnvironmentVariable;

constexpr dword BL_OBJ_TYPE_SYS_VARIABLE = -1;

/**
 * System variable that can be used with CANoe.
 */
typedef struct VBLSystemVariable {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Type of system variable. Following values are
     * possible:
     *
     * - 1: DOUBLE (BL_SYSVAR_TYPE_DOUBLE)
     * - 2: LONG (BL_SYSVAR_TYPE_LONG)
     * - 3: STRING (BL_SYSVAR_TYPE_STRING)
     * - 4: Array of DOUBLE
     *   (BL_SYSVAR_TYPE_DOUBLEARRAY)
     * - 5: Array of LONG
     *   (BL_SYSVAR_TYPE_LONGARRAY)
     * - 6: LONGLONG
     *   (BL_SYSVAR_TYPE_LONGLONG)
     * - 7: Array of BYTE
     *   (BL_SYSVAR_TYPE_BYTEARRAY)
     */
    enum mType : dword {
        BL_SYSVAR_TYPE_DOUBLE      = 1,
        BL_SYSVAR_TYPE_LONG        = 2,
        BL_SYSVAR_TYPE_STRING      = 3,
        BL_SYSVAR_TYPE_DOUBLEARRAY = 4,
        BL_SYSVAR_TYPE_LONGARRAY   = 5,
        BL_SYSVAR_TYPE_LONGLONG    = 6,
        BL_SYSVAR_TYPE_BYTEARRAY   = 7
    } mType;

    /**
     * Reserved, must be 0.
     */
    dword mReserved[3];

    /**
     * Length of the name of the system variable
     * (without terminating 0)
     */
    dword mNameLength;

    /**
     * Length of the data of the environment variable in
     * bytes.
     */
    dword mDataLength;

    /**
     * Name of the system variable.
     */
    lpstr mName;

    /**
     * Data value of the system variable.
     */
    lpbyte mData;
} VBLSystemVariable;

constexpr dword BL_OBJ_TYPE_GPS_EVENT = -1;

/**
 * GPS event.
 */
typedef struct VBLGPSEvent {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Not used, must be 0.
     */
    dword mFlags;

    /**
     * GPS channel the GPS event was sent.
     */
    word mChannel;

    /**
     * Reserved, must be 0.
     */
    word mReserved;

    /**
     * Latitude, possible values reach from -180 to 180.
     *
     * Negative values are western hemisphere, positive
     * values are eastern hemisphere.
     */
    double mLatitude;

    /**
     * Longitude, possible values reach from -90 to 90.
     * Negative values are Southern hemisphere,
     * positive values are northern hemisphere.
     */
    double mLongitude;

    /**
     * Altitude in meters, measured above sea line.
     */
    double mAltitude;

    /**
     * Current vehicle speed in km/h.
     */
    double mSpeed;

    /**
     * Current driving course, possible values reach
     * from -180 to 180. A value of 0 means driving
     * north, 90 means driving east, -90 means driving
     * west, -180 and 180 mean driving south.
     */
    double mCourse;
} VBLGPSEvent;

constexpr dword BL_OBJ_TYPE_ETHERNET_FRAME = -1;

/**
 * Ethernet frame.
 */
typedef struct VBLEthernetFrame {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Ethernet (MAC) address of source computer
     * (network byte order).
     */
    byte mSourceAddress[6];

    /**
     * The channel of the frame.
     */
    word mChannel;

    /**
     * Ethernet (MAC) address of target computer
     * (network byte order).
     */
    byte mDestinationAddress[6];

    /**
     * Direction flag: 0=Rx, 1=Tx, 2=TxRq
     */
    word mDir;

    /**
     * EtherType which indicates protocol for
     * Ethernet payload data
     *
     * See Ethernet standard specification for valid
     * values.
     */
    word mType;

    /**
     * TPID when VLAN tag valid, zero when no
     * VLAN. See Ethernet standard specification.
     */
    word mTPID;

    /**
     * TCI when VLAND tag valid, zero when no
     * VLAN. See Ethernet standard specification.
     */
    word mTCI;

    /**
     * Length of Ethernet payload data in bytes. Max.
     * 1500 Bytes (without Ethernet header)
     */
    word mPayLoadLength;

    /**
     * Ethernet payload data (without Ethernet
     * header)
     */
    byte * mPayLoad;
} VBLEthernetFrame;

constexpr dword BL_OBJ_TYPE_ETHERNET_STATUS = -1;

/**
 * Ethernet status event.
 */
typedef struct VBLEthernetStatus {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * The channel of the event.
     */
    word mChannel;

    /**
     * Valid fields:
     *
     * - Bit 0: Link Status
     * - Bit 1: Bit rate
     * - Bit 2: Ethernet Phy
     * - Bit 3: Duplex
     * - Bit 4: MDI Type
     * - Bit 5: Connector
     * - Bit 6: Clock Mode
     * - Bit 7: BroadR-Reach Pair
     */
    word mFlags;

    /**
     * - 0: Unknown
     * - 1: IEEE 802.3
     * - 2: BroadR-Reach
     */
    byte mEthernetPhy;

    /**
     * - 0: Unknown
     * - 1: Half Duplex
     * - 2: Full Duplex
     */
    byte mDuplex;

    /**
     * - 0: Unknown
     * - 1: Direct
     * - 2: Crossover
     */
    byte mMdi;

    /**
     * - 0: Unknown
     * - 1: RJ45
     * - 2: D-Sub
     */
    byte mConnector;

    /**
     * - 0: Unknown
     * - 1: Master
     * - 2: Slave
     */
    byte mClockMode;

    /**
     * - 0: Unknown
     * - 1: BR 1-pair
     * - 2: BR 2-pair
     * - 3: BR 4-pair
     */
    byte mPairs;

    byte mReserved;

    /**
     * Bitrate in [kbit/sec]
     */
    dword mBitRate;
} VBLEthernetStatus;

constexpr dword BL_OBJ_TYPE_ETHERNET_RX_ERROR = -1;

/**
 * Ethernet Rx error frame.
 */
typedef struct VBLEthernetRxError {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Length of this structure, without
     * sizeof(VBLObjectHeader) and without raw data
     * length
     */
    word mStructLength;

    /**
     * The channel of the frame.
     */
    word mChannel;

    /**
     * Direction flag: 0=Rx
     */
    word mDir;

    /**
     * Ethernet frame checksum.
     */
    word mFcs;

    /**
     * Number of valid raw ethernet data bytes, starting
     * with Target MAC ID.
     */
    word mFrameDataLength;

    /**
     * Error code:
     *
     * - 1: Data Length Error
     * - 2: Invalid CRC
     * - 3: Invalid Data received
     * - 4: Collision detected
     */
    dword mError;

    /**
     * Raw Ethernet frame data.
     */
    byte * mFrameData;
} VBLEthernetRxError;

constexpr dword BL_OBJ_TYPE_WLAN_FRAME = -1;

/**
 * WLAN frame.
 */
typedef struct VBLWlanFrame {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * The channel of the frame.
     */
    word mChannel;

    /**
     * Bit 0 – Genuine MAC Header
     */
    word mFlags;

    /**
     * Direction flag: 0=Rx, 1=Tx
     */
    byte mDir;

    /**
     * Channel number of the radio frequency, i.e 180
     * or 176
     */
    byte mRadioChannel;

    /**
     * Signal strength in [dBm]
     */
    short mSignalStrength;

    /**
     * Signal quality
     */
    word mSignalQuality;

    /**
     * Length of WLAN data in bytes. Max. 2342
     * Bytes.
     */
    word mFrameLength;

    /**
     * WLAN frame data. Data starts with WLAN
     * header.
     */
    byte * mFrameData;
} VBLWlanFrame;

constexpr dword BL_OBJ_TYPE_WLAN_STATISTIC = -1;

/**
 * WLAN statistic.
 */
typedef struct VBLWlanStatistic {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * The channel of the frame.
     */
    word mChannel;

    /**
     * - Bit 0: Valid Rx/Tx counter
     * - Bit 1: Valid error counter
     */
    word mFlags;

    /**
     * Number of Rx packets since last statistic event.
     */
    ulong mRxPacketCount;

    /**
     * Number of Rx bytes since last statistic event.
     */
    ulong mRxByteCount;

    /**
     * Number of Tx packets since last statistic event.
     */
    ulong mTxPacketCount;

    /**
     * Number of Tx bytes since last statistic event.
     */
    ulong mTxByteCount;

    /**
     * Number of collisions since last statistic event.
     */
    ulong mCollisionCount;

    /**
     * Number of errors since last statistic event.
     */
    ulong mErrorCount;
} VBLWlanStatistic;

constexpr dword BL_OBJ_TYPE_APP_TRIGGER = -1;

/**
 * Application defined trigger to be saved in BLF log file (currently not used in CANoe
 * / CANalyzer).
 */
typedef struct VBLAppTrigger {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Pre trigger time.
     */
    ulonglong mPreTriggerTime;

    /**
     * Post trigger time.
     */
    ulonglong mPostTriggerTime;

    /**
     * Trigger that channel belongs to.
     */
    word mChannel;

    /**
     * - 0: single trigger type
     * - 1: start logging trigger type
     * - 2: stop logging trigger type
     */
    word mFlags;

    /**
     * Reserved.
     */
    dword mAppSpecific2;
} VBLAppTrigger;

constexpr dword BL_OBJ_TYPE_APP_TEXT = -1;

typedef enum BL_APPTEXT {
    BL_APPTEXT_MEASUREMENTCOMMENT = 0,
    BL_APPTEXT_DBCHANNELINFO = 1
} BL_APPTEXT;

typedef enum BL_BUSTYPE {
    BL_BUSTYPE_CAN = 1,
    BL_BUSTYPE_LIN = 5,
    BL_BUSTYPE_MOST = 6,
    BL_BUSTYPE_FLEXRAY = 7,
    BL_BUSTYPE_J1708 = 9,
    BL_BUSTYPE_ETHERNET = 10,
    BL_BUSTYPE_WLAN = 13,
    BL_BUSTYPE_AFDX = 14
} BL_BUSTYPE;

/**
 * Application defined text to be saved in BLF log file (currently not used in
 * CANoe/CANalyzer).
 */
typedef struct VBLAppText {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Defines the source/semantic of the text. Actually two
     * different values are defined:
     *
     * 0: BL_APPTEXT_MEASUREMENTCOMMENT
     * - mReserved is not used
     * - mText contains a measurement comment
     *
     * 1: BL_APPTEXT_DBCHANNELINFO
     * - mReserved contains channel information. The following
     * - table show how the 4 bytes are used:
     *   - Bit 0-7: Version of the data
     *   - Bit 8-15: Channel number
     *   - Bit 15-23: Bus type of the channel. One of the
     *     following values:
     *     - 1: BL_BUSTYPE_CAN
     *     - 5: BL_BUSTYPE_LIN
     *     - 6: BL_BUSTYPE_MOST
     *     - 7: BL_BUSTYPE_FLEXRAY
     *     - 9: BL_BUSTYPE_J1708
     *     - 10: BL_BUSTYPE_ETHERNET
     *     - 13: BL_BUSTYPE_WLAN
     *     - 14: BL_BUSTYPE_AFDX
     *   - Bit 24: Flag, that determines, if channel is a CAN-
     *     FD channel
     *   - Bit 25-31: Unused at the moment
     * - mText contains database information for the specific
     *   channel. Each database is defined by the database path and
     *   the cluster name (if available). The single databases and the
     *   cluster name are separated by a semicolon. Example:
     *   <Path1>;<ClusterName1>;<Path2>;<ClusterName2>;...
     *   If for a database there's no cluster name available, an
     *   empty string is written as cluster name.
     */
    dword mSource;

    /**
     * Depends on mSource.
     */
    dword mReserved;

    /**
     * Length of mText without ending 0.
     */
    dword mTextLength;

    /**
     * Text to be saved to log file.
     */
    lpstr mText;
} VBLAppText;

constexpr dword BL_OBJ_TYPE_EVENT_COMMENT = -1;

/**
 * Comment of an event. The comment can be set in Trace Window.
 */
typedef struct VBLEventComment {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Type of the commented event
     */
    dword mCommentedEventType;

    /**
     * Length of mText without ending 0.
     */
    dword mTextLength;

    /**
     * Comment text.
     */
    lpstr mText;
} VBLEventComment;

constexpr dword BL_OBJ_TYPE_GLOBAL_MARKER = -1;

/**
 * Global Marker assigned to another event or to a time stamp.
 */
typedef struct VBLGlobalMarker {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Type of the commented events
     */
    dword mCommentedEventType;

    /**
     * Foreground color of the marker group.
     */
    colorref mForegroundColor;

    /**
     * Background color of the marker group.
     */
    colorref mBackgroundColor;

    /**
     * Defines whether a marker can be relocated
     */
    byte mIsRelocatable;

    /**
     * Length of mGroupName without ending 0.
     */
    dword mGroupNameLength;

    /**
     * Length of mMarkerName without ending 0.
     */
    dword mMarkerNameLength;

    /**
     * Length of mDescription without ending 0.
     */
    dword mDescriptionLength;

    /**
     * Group name.
     */
    lpstr mGroupName;

    /**
     * Marker.
     */
    lpstr mMarkerName;

    /**
     * Description text.
     */
    lpstr mDescription;
} VBLGlobalMarker;

constexpr dword BL_OBJ_TYPE_AFDX_FRAME = -1;

/**
 * AFDX frame.
 */
typedef struct VBLAfdxFrame {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * Ethernet (MAC) address of source computer
     * (network byte order).
     */
    byte mSourceAddress[6];

    /**
     * The channel of the frame.
     */
    word mChannel;

    /**
     * Ethernet (MAC) address of target computer
     * (network byte order).
     */
    byte mDestinationAddress[6];

    /**
     * Direction flag: 0=Rx, 1=Tx, 2=TxRq
     */
    word mDir;

    /**
     * EtherType which indicates protocol for
     * Ethernet payload data
     *
     * See Ethernet standard specification for valid
     * values.
     */
    word mType;

    /**
     * TPID when VLAN tag valid, zweo when no
     * VLAN. See Ethernet stnadard specification.
     */
    word mTPID;

    /**
     * TCI when VLAND tag valid, zero when no
     * VLAN. See Ethernet standard specification.
     */
    word mTCI;

    /**
     * Channel number of the underlying Ethernet
     * interface, where the frame originated from.
     */
    byte mEthChannel;

    /**
     * Status- and error flags as:
     *
     * - Bit 0: Frame from line-B
     * - Bit 1: Packet is redundant
     * - Bit 2: Frame is a fragment only
     * - Bit 3: Frame is already reassembled
     * - Bit 4: Packet is not a valid AFDX frame
     * - Bit 5: AFDX-SequenceNo is invalud
     * - Bit 6: Redundancy timeout violated
     * - Bit 7: Redundancy error encountered
     * - Bit 8: A / B interface mismatch
     * - Bit 11: Fragmentation error
     */
    word mAfdxFlags;

    /**
     * Time period since last received frame on this
     * virtual link in micro-seconds
     */
    ulong mBAGusec;

    /**
     * Length of Ethernet payload data in bytes. Max.
     * 1500 Bytes (without Ethernet header)
     */
    word mPayLoadLength;

    /**
     * Ethernet payload data (without Ethernet
     * header)
     */
    byte * mPayLoad;
} VBLAfdxFrame;

constexpr dword BL_OBJ_TYPE_AFDX_STATISTIC = -1;

/**
 * AFDX statistic event per virtual link.
 */
typedef struct VBLAfdxStatistic {
    /**
     * Common header type.
     */
    VBLObjectHeader mHeader;

    /**
     * The channel of the frame.
     */
    word mChannel;

    /**
     * - Bit 0: Valid Rx/Tx counter
     * - Bit 1: Valid error counter
     * - Bit 2: Valid VirtualLink ID
     */
    word mFlags;

    /**
     * Number of Rx packets since last
     * statistic event.
     */
    ulong mRxPacketCount;

    /**
     * Number of Rx bytes since last
     * statistic event.
     */
    ulong mRxByteCount;

    /**
     * Number of Tx packets since last
     * statistic event.
     */
    ulong mTxPacketCount;

    /**
     * Number of Tx bytes since last
     * statistic event.
     */
    ulong mTxByteCount;

    /**
     * Number of collisions since last
     * statistic event.
     */
    ulong mCollisionCount;

    /**
     * Number of errors since last statistic
     * event.
     */
    ulong mErrorCount;

    /**
     * Number of dropped packet due to
     * redundancy check since last
     * statistic event.
     */
    ulong mStatDroppedRedundantPacketCount;

    /**
     * Number of errors found at
     * redundancy check since last
     * statistic event.
     */
    ulong mStatDroppedRedundantErrorCount;

    /**
     * Number of errors found at integrity
     * check since last statistic event.
     */
    ulong mStatDroppedIntegrityErrorCount;

    /**
     * Average period of frames on this
     * VL in [msec].
     */
    ulong mStatAvrgPeriodMsec;

    /**
     * Average jitter of the time period of
     * frames on this VL in [mysec].
     */
    ulong mStatAvrgJitterMysec;

    /**
     * Unique ID assigned to this VL.
     */
    ulong mVLId;

    /**
     * Time period covered by this event
     * in [msec].
     */
    ulong mStatDuration;
} VBLAfdxStatistic;

}
}
